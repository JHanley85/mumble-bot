/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const ovrSuccess: ::std::os::raw::c_uint = 0;
pub const OVR_AUDIO_MAJOR_VERSION: ::std::os::raw::c_uint = 1;
pub const OVR_AUDIO_MINOR_VERSION: ::std::os::raw::c_uint = 22;
pub const OVR_AUDIO_PATCH_VERSION: ::std::os::raw::c_uint = 0;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type ovrResult = i32;
#[repr(u32)]
/// Enumerates error codes that can be returned by OVRAudio
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrAudioError {
    ovrError_AudioUnknown = 2000,
    ovrError_AudioInvalidParam = 2001,
    ovrError_AudioBadSampleRate = 2002,
    ovrError_AudioMissingDLL = 2003,
    ovrError_AudioBadAlignment = 2004,
    ovrError_AudioUninitialized = 2005,
    ovrError_AudioHRTFInitFailure = 2006,
    ovrError_AudioBadVersion = 2007,
    ovrError_AudioSymbolNotFound = 2008,
    ovrError_SharedReverbDisabled = 2009,
    ovrError_AudioNoAvailableAmbisonicInstance = 2017,
    ovrError_AudioInternalEnd = 2099,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrPosef_ {
    _unused: [u8; 0],
}
pub type ovrPosef = ovrPosef_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrPoseStatef_ {
    _unused: [u8; 0],
}
pub type ovrPoseStatef = ovrPoseStatef_;
#[repr(u32)]
/// Audio source flags
///
/// \see ovrAudio_SetAudioSourceFlags
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrAudioSourceFlag {
    ovrAudioSourceFlag_None = 0,
    ovrAudioSourceFlag_WideBand_HINT = 16,
    ovrAudioSourceFlag_NarrowBand_HINT = 32,
    ovrAudioSourceFlag_BassCompensation_DEPRECATED = 64,
    ovrAudioSourceFlag_DirectTimeOfArrival = 128,
    ovrAudioSourceFlag_ReflectionsDisabled = 256,
    ovrAudioSourceFlag_DisableResampling_RESERVED = 32768,
}
#[repr(u32)]
/// Audio source attenuation mode
///
/// \see ovrAudio_SetAudioSourceAttenuationMode
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrAudioSourceAttenuationMode {
    ovrAudioSourceAttenuationMode_None = 0,
    ovrAudioSourceAttenuationMode_Fixed = 1,
    ovrAudioSourceAttenuationMode_InverseSquare = 2,
    ovrAudioSourceAttenuationMode_COUNT = 3,
}
#[repr(u32)]
/// Global boolean flags
///
/// \see ovrAudio_Enable
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrAudioEnable {
    ovrAudioEnable_None = 0,
    ovrAudioEnable_SimpleRoomModeling = 2,
    ovrAudioEnable_LateReverberation = 3,
    ovrAudioEnable_RandomizeReverb = 4,
    ovrAudioEnable_PerSourceReverb = 5,
    ovrAudioEnable_COUNT = 6,
}
#[repr(u32)]
/// Internal use only
///
/// Internal use only
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrAudioHRTFInterpolationMethod {
    ovrAudioHRTFInterpolationMethod_Nearest = 0,
    ovrAudioHRTFInterpolationMethod_SimpleTimeDomain = 1,
    ovrAudioHRTFInterpolationMethod_MinPhaseTimeDomain = 2,
    ovrAudioHRTFInterpolationMethod_PhaseTruncation = 3,
    ovrAudioHRTFInterpolationMethod_PhaseLerp = 4,
    ovrAudioHRTFInterpolationMethod_COUNT = 5,
}
#[repr(u32)]
/// Status mask returned by spatializer APIs
///
/// Mask returned from spatialization APIs consists of combination of these.
/// \see ovrAudio_SpatializeMonoSourceLR
/// \see ovrAudio_SpatializeMonoSourceInterleaved
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrAudioSpatializationStatus {
    ovrAudioSpatializationStatus_None = 0,
    ovrAudioSpatializationStatus_Finished = 1,
    ovrAudioSpatializationStatus_Working = 2,
}
#[repr(i32)]
/// Headphone models used for correction
///
/// \see ovrAudio_SetHeadphoneModel.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrAudioHeadphones {
    ovrAudioHeadphones_None = -1,
    ovrAudioHeadphones_Rift = 0,
    ovrAudioHeadphones_Rift_INTERNAL0 = 1,
    ovrAudioHeadphones_Rift_INTERNAL1 = 2,
    ovrAudioHeadphones_Rift_INTERNAL2 = 3,
    ovrAudioHeadphones_Rift_INTERNAL3 = 4,
    ovrAudioHeadphones_Rift_INTERNAL4 = 5,
    ovrAudioHeadphones_Custom = 10,
    ovrAudioHeadphones_COUNT = 11,
}
#[repr(u32)]
/// Performance counter enumerants
///
/// \see ovrAudio_GetPerformanceCounter
/// \see ovrAudio_SetPerformanceCounter
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrAudioPerformanceCounter {
    ovrAudioPerformanceCounter_Spatialization = 0,
    ovrAudioPerformanceCounter_SharedReverb = 1,
    ovrAudioPerformanceCounter_HeadphoneCorrection = 2,
    ovrAudioPerformanceCounter_COUNT = 3,
}
#[repr(u32)]
/// Ambisonic formats
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrAudioAmbisonicFormat {
    ovrAudioAmbisonicFormat_FuMa = 0,
    ovrAudioAmbisonicFormat_AmbiX = 1,
}
#[repr(i32)]
/// Virtual speaker layouts for ambisonics
///
/// Provides a variety of virtual speaker layouts for ambisonic playback. The default is Spherical Harmonics which is a experimental approach that uses no virtual speakers at all and provides better externalization but can exhibit some artifacts with broadband content.
/// 
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrAudioAmbisonicSpeakerLayout {
    ovrAudioAmbisonicSpeakerLayout_FrontOnly = 0,
    ovrAudioAmbisonicSpeakerLayout_Octahedron = 1,
    ovrAudioAmbisonicSpeakerLayout_Cube = 2,
    ovrAudioAmbisonicSpeakerLayout_Icosahedron = 3,
    ovrAudioAmbisonicSpeakerLayout_Dodecahedron = 4,
    ovrAudioAmbisonicSpeakerLayout_20PointElectron = 5,
    ovrAudioAmbisonicSpeakerLayout_SphericalHarmonics = -1,
    ovrAudioAmbisonicSpeakerLayout_Mono = -2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrAudioSource_ {
    _unused: [u8; 0],
}
/// Opaque type definitions for audio source and context
pub type ovrAudioSource = ovrAudioSource_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrAudioContext_ {
    _unused: [u8; 0],
}
pub type ovrAudioContext = *mut ovrAudioContext_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrAudioAmbisonicStream_ {
    _unused: [u8; 0],
}
pub type ovrAudioAmbisonicStream = *mut ovrAudioAmbisonicStream_;
pub type ovrAudioSpectrumAnalyzer = *mut ::std::os::raw::c_void;
extern "C" {
    /// Return library's built version information.
///
/// Can be called any time.
/// \param[out] Major pointer to integer that accepts major version number
/// \param[out] Minor pointer to integer that accepts minor version number
/// \param[out] Patch pointer to integer that accepts patch version number
///
/// \return Returns a string with human readable build information
///
    pub fn ovrAudio_GetVersion(Major: *mut ::std::os::raw::c_int,
                               Minor: *mut ::std::os::raw::c_int,
                               Patch: *mut ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Allocate properly aligned buffer to store samples.
///
/// Helper function that allocates 16-byte aligned sample data sufficient
/// for passing to the spatialization APIs.
///
/// \param NumSamples number of samples to allocate 
/// \return Returns pointer to 16-byte aligned float buffer, or NULL on failure
/// \see ovrAudio_FreeSamples
///
    pub fn ovrAudio_AllocSamples(NumSamples: ::std::os::raw::c_int)
     -> *mut f32;
}
extern "C" {
    /// Free previously allocated buffer
///
/// Helper function that frees 16-byte aligned sample data previously
/// allocated by ovrAudio_AllocSamples.
///
/// \param Samples pointer to buffer previously allocated by ovrAudio_AllocSamples
/// \see ovrAudio_AllocSamples
///
    pub fn ovrAudio_FreeSamples(Samples: *mut f32);
}
extern "C" {
    /// Retrieve a transformation from an ovrPosef.
///
/// \param Pose[in] pose to fetch transform from
/// \param Vx[out] buffer to store orientation vector X
/// \param Vy[out] buffer to store orientation vector Y
/// \param Vz[out] buffer to store orientation vector Z
/// \param Pos[out] buffer to store position
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_GetTransformFromPose(Pose: *const ovrPosef, Vx: *mut f32,
                                         Vy: *mut f32, Vz: *mut f32,
                                         Pos: *mut f32) -> ovrResult;
}
/// Audio context configuration structure
///
/// Passed to ovrAudio_CreateContext
///
/// \see ovrAudio_CreateContext
///
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ovrAudioContextConfig {
    ///< set to size of the struct
    pub acc_Size: u32,
    ///< maximum number of audio sources to support
    pub acc_MaxNumSources: u32,
    ///< sample rate (16000 to 48000, but 44100 and 48000 are recommended for best quality)
    pub acc_SampleRate: u32,
    ///< number of samples in mono input buffers passed to spatializer
    pub acc_BufferLength: u32,
}
#[test]
fn bindgen_test_layout__ovrAudioContextConfig() {
    assert_eq!(::std::mem::size_of::<_ovrAudioContextConfig>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _ovrAudioContextConfig )
               ));
    assert_eq! (::std::mem::align_of::<_ovrAudioContextConfig>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _ovrAudioContextConfig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioContextConfig ) ) . acc_Size as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ovrAudioContextConfig
                ) , "::" , stringify ! ( acc_Size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioContextConfig ) ) .
                acc_MaxNumSources as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( _ovrAudioContextConfig
                ) , "::" , stringify ! ( acc_MaxNumSources ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioContextConfig ) ) .
                acc_SampleRate as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _ovrAudioContextConfig
                ) , "::" , stringify ! ( acc_SampleRate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioContextConfig ) ) .
                acc_BufferLength as * const _ as usize } , 12usize , concat !
                (
                "Alignment of field: " , stringify ! ( _ovrAudioContextConfig
                ) , "::" , stringify ! ( acc_BufferLength ) ));
}
impl Clone for _ovrAudioContextConfig {
    fn clone(&self) -> Self { *self }
}
pub type ovrAudioContextConfiguration = _ovrAudioContextConfig;
extern "C" {
    /// Create an audio context for spatializing incoming sounds.
///
/// Creates an audio context with the given configuration.
///
/// \param pContext[out] pointer to store address of context.  NOTE: pointer must be pointing to NULL!
/// \param pConfig[in] pointer to configuration struct describing the desired context attributes
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_DestroyContext
/// \see ovrAudioContextConfiguration
///
    pub fn ovrAudio_CreateContext(pContext: *mut ovrAudioContext,
                                  pConfig:
                                      *const ovrAudioContextConfiguration)
     -> ovrResult;
}
extern "C" {
    /// Destroy a previously created audio context.
///
/// \param[in] Context a valid audio context
/// \see ovrAudio_CreateContext
///
    pub fn ovrAudio_DestroyContext(Context: ovrAudioContext);
}
extern "C" {
    /// Enable/disable options in the audio context.
///
/// \param Context context to use
/// \param What specific property to enable/disable
/// \param Enable 0 to disable, 1 to enable
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_Enable(Context: ovrAudioContext, What: ovrAudioEnable,
                           Enable: ::std::os::raw::c_int) -> ovrResult;
}
extern "C" {
    /// Query option status in the audio context.
///
/// \param Context context to use
/// \param What specific property to query
/// \param pEnabled addr of variable to receive the queried property status
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_IsEnabled(Context: ovrAudioContext, What: ovrAudioEnable,
                              pEnabled: *mut ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    /// Set HRTF interpolation method.
///
/// NOTE: Internal use only!
/// \param Context context to use
/// \param InterpolationMethod method to use
///
    pub fn ovrAudio_SetHRTFInterpolationMethod(Context: ovrAudioContext,
                                               InterpolationMethod:
                                                   ovrAudioHRTFInterpolationMethod)
     -> ovrResult;
}
extern "C" {
    /// Get HRTF interpolation method.
///
/// NOTE: Internal use only!
/// \param Context context to use
/// \param InterpolationMethod method to use
///
    pub fn ovrAudio_GetHRTFInterpolationMethod(Context: ovrAudioContext,
                                               pInterpolationMethod:
                                                   *mut ovrAudioHRTFInterpolationMethod)
     -> ovrResult;
}
/// Box room parameters used by ovrAudio_SetSimpleBoxRoomParameters
///
/// \see ovrAudio_SetSimpleBoxRoomParameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _ovrAudioBoxRoomParameters {
    ///< Size of struct
    pub brp_Size: u32,
    ///< Reflection values (0..0.95)
    pub brp_ReflectLeft: f32,
    ///< Reflection values (0..0.95)
    pub brp_ReflectRight: f32,
    ///< Reflection values (0..0.95)
    pub brp_ReflectUp: f32,
    ///< Reflection values (0..0.95)
    pub brp_ReflectDown: f32,
    ///< Reflection values (0..0.95)
    pub brp_ReflectBehind: f32,
    ///< Reflection values (0..0.95)
    pub brp_ReflectFront: f32,
    ///< Size of box in meters
    pub brp_Width: f32,
    ///< Size of box in meters
    pub brp_Height: f32,
    ///< Size of box in meters
    pub brp_Depth: f32,
}
#[test]
fn bindgen_test_layout__ovrAudioBoxRoomParameters() {
    assert_eq!(::std::mem::size_of::<_ovrAudioBoxRoomParameters>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( _ovrAudioBoxRoomParameters ) ));
    assert_eq! (::std::mem::align_of::<_ovrAudioBoxRoomParameters>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( _ovrAudioBoxRoomParameters )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioBoxRoomParameters ) ) . brp_Size
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _ovrAudioBoxRoomParameters ) , "::" , stringify ! ( brp_Size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioBoxRoomParameters ) ) .
                brp_ReflectLeft as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _ovrAudioBoxRoomParameters ) , "::" , stringify ! (
                brp_ReflectLeft ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioBoxRoomParameters ) ) .
                brp_ReflectRight as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _ovrAudioBoxRoomParameters ) , "::" , stringify ! (
                brp_ReflectRight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioBoxRoomParameters ) ) .
                brp_ReflectUp as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                _ovrAudioBoxRoomParameters ) , "::" , stringify ! (
                brp_ReflectUp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioBoxRoomParameters ) ) .
                brp_ReflectDown as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _ovrAudioBoxRoomParameters ) , "::" , stringify ! (
                brp_ReflectDown ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioBoxRoomParameters ) ) .
                brp_ReflectBehind as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _ovrAudioBoxRoomParameters ) , "::" , stringify ! (
                brp_ReflectBehind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioBoxRoomParameters ) ) .
                brp_ReflectFront as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _ovrAudioBoxRoomParameters ) , "::" , stringify ! (
                brp_ReflectFront ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioBoxRoomParameters ) ) .
                brp_Width as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                _ovrAudioBoxRoomParameters ) , "::" , stringify ! ( brp_Width
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioBoxRoomParameters ) ) .
                brp_Height as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _ovrAudioBoxRoomParameters ) , "::" , stringify ! ( brp_Height
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ovrAudioBoxRoomParameters ) ) .
                brp_Depth as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                _ovrAudioBoxRoomParameters ) , "::" , stringify ! ( brp_Depth
                ) ));
}
impl Clone for _ovrAudioBoxRoomParameters {
    fn clone(&self) -> Self { *self }
}
pub type ovrAudioBoxRoomParameters = _ovrAudioBoxRoomParameters;
extern "C" {
    /// Set box room parameters for reverberation.
///
/// These parameters are used for reverberation/early reflections if 
/// ovrAudioEnable_SimpleRoomModeling is enabled.
///
/// Width/Height/Depth default is 11/10/9m
/// Reflection constants default to 0.25
///
/// \param Context[in] context to use
/// \param Parameters[in] pointer to ovrAudioBoxRoomParameters describing box
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudioBoxRoomParameters
/// \see ovrAudio_Enable
///
    pub fn ovrAudio_SetSimpleBoxRoomParameters(Context: ovrAudioContext,
                                               Parameters:
                                                   *const ovrAudioBoxRoomParameters)
     -> ovrResult;
}
extern "C" {
    /// Get box room parameters for current reverberation.
///
/// \param Context[in] context to use
/// \param Parameters[in] pointer to returned ovrAudioBoxRoomParameters box description
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudioBoxRoomParameters
/// \see ovrAudio_Enable
///
    pub fn ovrAudio_GetSimpleBoxRoomParameters(Context: ovrAudioContext,
                                               Parameters:
                                                   *mut ovrAudioBoxRoomParameters)
     -> ovrResult;
}
extern "C" {
    /// Sets the listener's pose state as vectors
///
/// If this is not set then the listener is always assumed to be facing into
/// the screen (0,0,-1) at location (0,0,0) and that all spatialized sounds
/// are in listener-relative coordinates.
///
/// \param Context[in] context to use
/// \param PositionX[in] X position of listener on X axis
/// \param PositionY[in] Y position of listener on X axis
/// \param PositionZ[in] Z position of listener on X axis
/// \param ForwardX[in] X component of listener forward vector
/// \param ForwardY[in] Y component of listener forward vector
/// \param ForwardZ[in] Z component of listener forward vector
/// \param UpX[in] X component of listener up vector
/// \param UpY[in] Y component of listener up vector
/// \param UpZ[in] Z component of listener up vector
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_SetListenerVectors(Context: ovrAudioContext,
                                       PositionX: f32, PositionY: f32,
                                       PositionZ: f32, ForwardX: f32,
                                       ForwardY: f32, ForwardZ: f32, UpX: f32,
                                       UpY: f32, UpZ: f32) -> ovrResult;
}
extern "C" {
    /// Gets the listener's pose state as vectors
///
/// \param Context[in] context to use
/// \param pPositionX[in]: addr of X position of listener on X axis
/// \param pPositionY[in]: addr of Y position of listener on X axis
/// \param pPositionZ[in]: addr of Z position of listener on X axis
/// \param pForwardX[in]: addr of X component of listener forward vector
/// \param pForwardY[in]: addr of Y component of listener forward vector
/// \param pForwardZ[in]: addr of Z component of listener forward vector
/// \param pUpX[in]: addr of X component of listener up vector
/// \param pUpY[in]: addr of Y component of listener up vector
/// \param pUpZ[in]: addr of Z component of listener up vector
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_GetListenerVectors(Context: ovrAudioContext,
                                       pPositionX: *mut f32,
                                       pPositionY: *mut f32,
                                       pPositionZ: *mut f32,
                                       pForwardX: *mut f32,
                                       pForwardY: *mut f32,
                                       pForwardZ: *mut f32, pUpX: *mut f32,
                                       pUpY: *mut f32, pUpZ: *mut f32)
     -> ovrResult;
}
extern "C" {
    /// Sets the listener's pose state
///
/// If this is not set then the listener is always assumed to be facing into
/// the screen (0,0,-1) at location (0,0,0) and that all spatialized sounds
/// are in listener-relative coordinates.
///
/// \param Context[in] context to use
/// \param PoseState[in] listener's pose state as returned by LibOVR
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_SetListenerPoseStatef(Context: ovrAudioContext,
                                          PoseState: *const ovrPoseStatef)
     -> ovrResult;
}
extern "C" {
    /// Reset an audio source's state.
///
/// Sometimes you need to reset an audio source's internal state due to a change
/// in the incoming sound or parameters.  For example, removing any reverb
/// tail since the incoming waveform has been swapped.
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_ResetAudioSource(Context: ovrAudioContext,
                                     Sound: ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    /// Sets the position of an audio source.  Use "OVR" coordinate system (same as pose).
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param X position of sound on X axis
/// \param Y position of sound on Y axis
/// \param Z position of sound on Z axis
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_SetListenerPoseStatef
/// \see ovrAudio_SetAudioSourceRange
///
    pub fn ovrAudio_SetAudioSourcePos(Context: ovrAudioContext,
                                      Sound: ::std::os::raw::c_int, X: f32,
                                      Y: f32, Z: f32) -> ovrResult;
}
extern "C" {
    /// Gets the position of an audio source.  Use "OVR" coordinate system (same as pose).
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param pX address of position of sound on X axis
/// \param pY address of position of sound on Y axis
/// \param pZ address of position of sound on Z axis
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_SetListenerPoseStatef
/// \see ovrAudio_SetAudioSourceRange
///
    pub fn ovrAudio_GetAudioSourcePos(Context: ovrAudioContext,
                                      Sound: ::std::os::raw::c_int,
                                      pX: *mut f32, pY: *mut f32,
                                      pZ: *mut f32) -> ovrResult;
}
extern "C" {
    /// Sets the min and max range of the audio source.
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param RangeMin min range in meters (full gain)
/// \param RangeMax max range in meters
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_SetListenerPoseStatef
/// \see ovrAudio_SetAudioSourcePos
///
    pub fn ovrAudio_SetAudioSourceRange(Context: ovrAudioContext,
                                        Sound: ::std::os::raw::c_int,
                                        RangeMin: f32, RangeMax: f32)
     -> ovrResult;
}
extern "C" {
    /// Gets the min and max range of the audio source.
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param pRangeMin addr of variable to receive the returned min range parameter (in meters).
/// \param pRangeMax addr of variable to receive the returned max range parameter (in meters).
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_SetListenerPoseStatef
/// \see ovrAudio_SetAudioSourcePos
/// \see ovrAudio_SetAudioSourceRange
///
    pub fn ovrAudio_GetAudioSourceRange(Context: ovrAudioContext,
                                        Sound: ::std::os::raw::c_int,
                                        pRangeMin: *mut f32,
                                        pRangeMax: *mut f32) -> ovrResult;
}
extern "C" {
    /// Sets the radius of the audio source for volumetric sound sources. Set a radius of 0 to make it a point source.
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param Radius source radius in meters
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_SetListenerPoseStatef
/// \see ovrAudio_SetAudioSourcePos
///
    pub fn ovrAudio_SetAudioSourceRadius(Context: ovrAudioContext,
                                         Sound: ::std::os::raw::c_int,
                                         Radius: f32) -> ovrResult;
}
extern "C" {
    /// Gets the radius of the audio source for volumetric sound sources.
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param pRadiusMin addr of variable to receive the returned radius parameter (in meters).
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_SetListenerPoseStatef
/// \see ovrAudio_SetAudioSourcePos
/// \see ovrAudio_SetAudioSourceRadius
///
    pub fn ovrAudio_GetAudioSourceRadius(Context: ovrAudioContext,
                                         Sound: ::std::os::raw::c_int,
                                         pRadius: *mut f32) -> ovrResult;
}
extern "C" {
    /// Sets an audio source's flags.
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param Flags a logical OR of ovrAudioSourceFlag enumerants
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_SetAudioSourceFlags(Context: ovrAudioContext,
                                        Sound: ::std::os::raw::c_int,
                                        Flags: u32) -> ovrResult;
}
extern "C" {
    /// Gets an audio source's flags.
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param pFlags addr of returned flags (a logical OR of ovrAudioSourceFlag enumerants)
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_GetAudioSourceFlags(Context: ovrAudioContext,
                                        Sound: ::std::os::raw::c_int,
                                        pFlags: *mut u32) -> ovrResult;
}
extern "C" {
    /// Sets the direction of an audio source.  Use "OVR" coordinate system (same as pose).
///
/// This is an experimental feature only.  Vn should be a unit vector pointing AWAY from
/// the sound source.
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param VX X component of direction vector
/// \param VY Y component of direction vector
/// \param VZ Z component of direction vector
/// \param Angle Cone angle of the sound source in degrees.  A value of 0 disables directionality.
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_SetListenerPoseStatef
/// \see ovrAudio_SetAudioSourceRange
/// \see ovrAudio_SetAudioSourcePos
///
    pub fn ovrAudio_SetAudioSourceDirectionRESERVED(Context: ovrAudioContext,
                                                    Sound:
                                                        ::std::os::raw::c_int,
                                                    VX: f32, VY: f32, VZ: f32,
                                                    Angle: f32) -> ovrResult;
}
extern "C" {
    /// Set the attenuation mode for a sound source.
///
/// Sounds can have their volume attenuated by distance based on different methods.
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param Mode attenuation mode to use
/// \param FixedScale attenuation constant used for fixed attenuation mode
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_SetAudioSourceAttenuationMode(Context: ovrAudioContext,
                                                  Sound:
                                                      ::std::os::raw::c_int,
                                                  Mode:
                                                      ovrAudioSourceAttenuationMode,
                                                  FixedScale: f32)
     -> ovrResult;
}
extern "C" {
    /// Get the attenuation mode for a sound source.
///
/// Sounds can have their volume attenuated by distance based on different methods.
///
/// \param Context context to use
/// \param Sound index of sound (0..NumSources-1)
/// \param pMode addr of returned attenuation mode in use
/// \param pFixedScale addr of returned attenuation constant used for fixed attenuation mode
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_GetAudioSourceAttenuationMode(Context: ovrAudioContext,
                                                  Sound:
                                                      ::std::os::raw::c_int,
                                                  pMode:
                                                      *mut ovrAudioSourceAttenuationMode,
                                                  pFixedScale: *mut f32)
     -> ovrResult;
}
extern "C" {
    /// Spatialize a mono audio source to interleaved stereo output.
///
/// \param Context[in] context to use
/// \param Sound[in] index of sound (0..NumSources-1)
/// \param InFlags[in] spatialization flags to apply 
/// \param OutStatus[out] bitwise OR of flags indicating status of currently playing sound
/// \param Dst[out] pointer to stereo interleaved floating point destination buffer
/// \param Src[in] pointer to mono floating point buffer to spatialize
/// \return Returns an ovrResult indicating success or failure
///
/// \see ovrAudio_SpatializeMonoSourceLR
///
    pub fn ovrAudio_SpatializeMonoSourceInterleaved(Context: ovrAudioContext,
                                                    Sound:
                                                        ::std::os::raw::c_int,
                                                    OutStatus: *mut u32,
                                                    Dst: *mut f32,
                                                    Src: *const f32)
     -> ovrResult;
}
extern "C" {
    /// Spatialize a mono audio source to separate left and right output buffers.
///
/// \param Context[in] context to use
/// \param Sound[in] index of sound (0..NumSources-1)
/// \param InFlags[in] spatialization flags to apply 
/// \param OutStatus[out] bitwise OR of flags indicating status of currently playing sound
/// \param DstLeft[out]  pointer to floating point left channel buffer
/// \param DstRight[out] pointer to floating point right channel buffer
/// \param Src[in] pointer to mono floating point buffer to spatialize
/// \return Returns an ovrResult indicating success or failure
///
/// \see ovrAudio_SpatializeMonoSourceInterleaved
///
    pub fn ovrAudio_SpatializeMonoSourceLR(Context: ovrAudioContext,
                                           Sound: ::std::os::raw::c_int,
                                           OutStatus: *mut u32,
                                           DstLeft: *mut f32,
                                           DstRight: *mut f32,
                                           Src: *const f32) -> ovrResult;
}
extern "C" {
    /// Set the headphone model used by the headphone correction algorithm.
///
/// \param Context[in] context to use
/// \param Model[in] model to use
/// \param ImpulseResponse[in] impulse response to use
/// \param NumSamples[in] size of impulse response in samples
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_ApplyHeadphoneCorrection
///
    pub fn ovrAudio_SetHeadphoneModel(Context: ovrAudioContext,
                                      Model: ovrAudioHeadphones,
                                      ImpulseResponse: *const f32,
                                      NumSamples: ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    /// Get the headphone model used by the headphone correction algorithm.
///
/// \param Context[in] context to use
/// \param pModel[in] addr of returned model used
/// \param pImpulseResponse[in] addr of returned impulse response used (as a readonly buffer)
/// \param pNumSamples[in] addr of returned size of impulse response in samples
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_ApplyHeadphoneCorrection
///
    pub fn ovrAudio_GetHeadphoneModel(Context: ovrAudioContext,
                                      pModel: *mut ovrAudioHeadphones,
                                      pImpulseResponse: *mut *const f32,
                                      pNumSamples: *mut ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    /// Apply headphone correction algorithm to stereo buffer.
///
/// NOTE: Currently unimplemented
///
/// \param Context[in] context to use
/// \param OutLeft[out] pointer to floating point left channel buffer destination
/// \param OutRight[out] pointer to floating point right channel buffer destination
/// \param InLeft[in] pointer to floating point left channel buffer source
/// \param InRight[in] pointer to floating point right channel buffer source
/// \param NumSamples size of buffers (in samples)
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_SetHeadphoneModel
///
    pub fn ovrAudio_ApplyHeadphoneCorrection(Context: ovrAudioContext,
                                             OutLeft: *mut f32,
                                             OutRight: *mut f32,
                                             InLeft: *const f32,
                                             InRight: *const f32,
                                             NumSamples:
                                                 ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    /// Mix shared reverb into buffer
///
/// \param Context[in] context to use
/// \param InFlags[in] spatialization flags to apply 
/// \param OutStatus[out] bitwise OR of flags indicating status of currently playing sound
/// \param OutLeft[out] pointer to floating point left channel buffer to mix into (MUST CONTAIN VALID AUDIO OR SILENCE)
/// \param OutRight[out] pointer to floating point right channel buffer to mix into (MUST CONTAIN VALID AUDIO OR SILENCE)
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_MixInSharedReverbLR(Context: ovrAudioContext,
                                        OutStatus: *mut u32,
                                        DstLeft: *mut f32, DstRight: *mut f32)
     -> ovrResult;
}
extern "C" {
    /// Mix shared reverb into interleaved buffer
///
/// \param Context[in] context to use
/// \param InFlags[in] spatialization flags to apply 
/// \param OutStatus[out] bitwise OR of flags indicating status of currently playing sound
/// \param DstInterleaved pointer to interleaved floating point left&right channels buffer to mix into (MUST CONTAIN VALID AUDIO OR SILENCE)
/// \return Returns an ovrResult indicating success or failure
///
    pub fn ovrAudio_MixInSharedReverbInterleaved(Context: ovrAudioContext,
                                                 OutStatus: *mut u32,
                                                 DstInterleaved: *mut f32)
     -> ovrResult;
}
extern "C" {
    /// Sets the min and max range of the shared reverb.
///
/// \param Context context to use
/// \param RangeMin min range in meters (full gain)
/// \param RangeMax max range in meters
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_SetListenerPoseStatef
/// \see ovrAudio_MixInSharedReverbLR
///
    pub fn ovrAudio_SetSharedReverbRange(Context: ovrAudioContext,
                                         RangeMin: f32, RangeMax: f32)
     -> ovrResult;
}
extern "C" {
    /// Gets the min and max range of the shared reverb.
///
/// \param Context context to use
/// \param pRangeMin addr of the returned min range in meters (full gain)
/// \param pRangeMax addr of the returned max range in meters
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_SetSharedReverbRange
/// \see ovrAudio_SetListenerPoseStatef
/// \see ovrAudio_MixInSharedReverbLR
///
    pub fn ovrAudio_GetSharedReverbRange(Context: ovrAudioContext,
                                         pRangeMin: *mut f32,
                                         pRangeMax: *mut f32) -> ovrResult;
}
extern "C" {
    /// Set user headRadius.
///
/// NOTE: This API is intended to let you set user configuration parameters that
/// may assist with spatialization.
///
/// \param Context[in] context to use
/// \param Config[in] configuration state
    pub fn ovrAudio_SetHeadRadius(Context: ovrAudioContext, HeadRadius: f32)
     -> ovrResult;
}
extern "C" {
    /// Set user configuration.
///
/// NOTE: This API is intended to let you set user configuration parameters that
/// may assist with spatialization.
///
/// \param Context[in] context to use
/// \param Config[in] configuration state
    pub fn ovrAudio_GetHeadRadius(Context: ovrAudioContext,
                                  HeadRadius: *mut f32) -> ovrResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ovrAudioPrivateAPI {
    _unused: [u8; 0],
}
/// \typedef ovrAudioPrivateAPI
/// \brief   Opaque type used for access to private/hidden functions.
///
pub type ovrAudioPrivateAPI = _ovrAudioPrivateAPI;
extern "C" {
    pub fn ovrAudio_GetPrivateAPI(Context: ovrAudioContext,
                                  Dst: *mut ovrAudioPrivateAPI) -> ovrResult;
}
extern "C" {
    /// Retrieve a performance counter.
///
/// \param Context[in] context to use
/// \param Counter[in] the counter to retrieve
/// \param Count[out] destination for count variable (number of times that counter was updated)
/// \param TimeMicroSeconds destination for total time spent in that performance counter
/// \return Returns an ovrResult indicating success or failure
/// \see ovrAudio_ResetPerformanceCounter
///
    pub fn ovrAudio_GetPerformanceCounter(Context: ovrAudioContext,
                                          Counter: ovrAudioPerformanceCounter,
                                          Count: *mut i64,
                                          TimeMicroSeconds: *mut f64)
     -> ovrResult;
}
extern "C" {
    /// Reset a performance counter.
///
/// \param Context[in] context to use
/// \param Counter[in] the counter to retrieve
/// \see ovrAudio_ResetPerformanceCounter
///
    pub fn ovrAudio_ResetPerformanceCounter(Context: ovrAudioContext,
                                            Counter:
                                                ovrAudioPerformanceCounter)
     -> ovrResult;
}
extern "C" {
    /// Quad-binaural spatialization 
///
/// \param ForwardLR[in] pointer to stereo interleaved floating point binaural audio for the forward direction (0 degrees)
/// \param RightLR[in] pointer to stereo interleaved floating point binaural audio for the right direction (90 degrees)
/// \param BackLR[in] pointer to stereo interleaved floating point binaural audio for the backward direction (180 degrees)
/// \param LeftLR[in] pointer to stereo interleaved floating point binaural audio for the left direction (270 degrees)
/// \param LookDirectionX[in] X component of the listener direction vector
/// \param LookDirectionY[in] Y component of the listener direction vector
/// \param LookDirectionZ[in] Z component of the listener direction vector
/// \param NumSamples[in] size of audio buffers (in samples)
/// \param Dst[out] pointer to stereo interleaved floating point destination buffer
///
    pub fn ovrAudio_ProcessQuadBinaural(ForwardLR: *const f32,
                                        RightLR: *const f32,
                                        BackLR: *const f32,
                                        LeftLR: *const f32,
                                        LookDirectionX: f32,
                                        LookDirectionY: f32,
                                        LookDirectionZ: f32,
                                        NumSamples: ::std::os::raw::c_int,
                                        Dst: *mut f32) -> ovrResult;
}
extern "C" {
    /// Create an ambisonic stream instance for spatializing B-format ambisonic audio
///
/// \param SampleRate[in] sample rate of B-format signal (16000 to 48000, but 44100 and 48000 are recommended for best quality)
/// \param AudioBufferLength[in] size of audio buffers
/// \param pContext[out] pointer to store address of stream.
///
    pub fn ovrAudio_CreateAmbisonicStream(Context: ovrAudioContext,
                                          SampleRate: ::std::os::raw::c_int,
                                          AudioBufferLength:
                                              ::std::os::raw::c_int,
                                          format: ovrAudioAmbisonicFormat,
                                          ambisonicOrder:
                                              ::std::os::raw::c_int,
                                          pAmbisonicStream:
                                              *mut ovrAudioAmbisonicStream)
     -> ovrResult;
}
extern "C" {
    /// Reset a previously created ambisonic stream for re-use
///
/// \param[in] Context a valid ambisonic stream
///
    pub fn ovrAudio_ResetAmbisonicStream(AmbisonicStream:
                                             ovrAudioAmbisonicStream)
     -> ovrResult;
}
extern "C" {
    /// Destroy a previously created ambisonic stream.
///
/// \param[in] Context a valid ambisonic stream
/// \see ovrAudio_CreateAmbisonicStream
///
    pub fn ovrAudio_DestroyAmbisonicStream(AmbisonicStream:
                                               ovrAudioAmbisonicStream)
     -> ovrResult;
}
extern "C" {
    /// Sets the virtual speaker layout for the ambisonic stream.
///
/// \param[in] Context a valid ambisonic stream
/// \see ovrAudioAmbisonicSpeakerLayout
///
    pub fn ovrAudio_SetAmbisonicSpeakerLayout(AmbisonicStream:
                                                  ovrAudioAmbisonicStream,
                                              Layout:
                                                  ovrAudioAmbisonicSpeakerLayout)
     -> ovrResult;
}
extern "C" {
    /// Sets the virtual speaker layout for the ambisonic stream.
///
/// \param[in] Context a valid ambisonic stream
/// \see ovrAudioAmbisonicSpeakerLayout
///
    pub fn ovrAudio_GetAmbisonicSpeakerLayout(AmbisonicStream:
                                                  ovrAudioAmbisonicStream,
                                              Layout:
                                                  *mut ovrAudioAmbisonicSpeakerLayout)
     -> ovrResult;
}
extern "C" {
    /// Spatialize a mono in ambisonics
///
/// \param InMono[in] Mono audio buffer to spatialize
/// \param DirectionX[in] X component of the direction vector
/// \param DirectionY[in] Y component of the direction vector
/// \param DirectionZ[in] Z component of the direction vector
/// \param Format[in] ambisonic format (AmbiX or FuMa)
/// \param AmbisonicOrder[in] order of ambisonics (1 or 2)
/// \param OutAmbisonic[out] Buffer to write interleaved ambisonics to (4 channels for 1st order, 9 channels for second order)
/// \param NumSamples[in] Length of the buffer in frames (InMono is this length, OutAmbisonic is either 4 or 9 times this length depending on 1st or 2nd order)
///
    pub fn ovrAudio_MonoToAmbisonic(InMono: *const f32, DirectionX: f32,
                                    DirectionY: f32, DirectionZ: f32,
                                    Format: ovrAudioAmbisonicFormat,
                                    AmbisonicOrder: ::std::os::raw::c_int,
                                    OutAmbisonic: *mut f32,
                                    NumSamples: ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    /// Render a speaker feed from ambisonics
///
/// \param InAmbisonics[in] Interleaved ambisonic audio buffer to render (4 channels for 1st order, 9 channels for second order)
/// \param DirectionX[in] X component of the direction vector
/// \param DirectionY[in] Y component of the direction vector
/// \param DirectionZ[in] Z component of the direction vector
/// \param Format[in] ambisonic format (AmbiX or FuMa)
/// \param AmbisonicOrder[in] order of ambisonics (1 or 2)
/// \param OutSpeakerFeed[out] Buffer to write speaker feed to 
/// \param NumSamples[in] Length of the buffer in frames (OutSpeakerFeed is this length, InAmbisonics is either 4 or 9 times this length depending on 1st or 2nd order)
///
    pub fn ovrAudio_RenderAmbisonicSpeakerFeed(InAmbisonics: *const f32,
                                               DirectionX: f32,
                                               DirectionY: f32,
                                               DirectionZ: f32,
                                               Format:
                                                   ovrAudioAmbisonicFormat,
                                               AmbisonicOrder:
                                                   ::std::os::raw::c_int,
                                               SpeakerFeed: *mut f32,
                                               NumSamples:
                                                   ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    /// Spatialize ambisonic stream
///
/// \param Src[in] pointer to 4 channel interleaved B-format floating point buffer to spatialize
/// \param Dst[out] pointer to stereo interleaved floating point destination buffer
///
    pub fn ovrAudio_ProcessAmbisonicStreamInterleaved(Context:
                                                          ovrAudioContext,
                                                      AmbisonicStream:
                                                          ovrAudioAmbisonicStream,
                                                      Src: *const f32,
                                                      Dst: *mut f32,
                                                      NumSamples:
                                                          ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    /// Set orientation for ambisonic stream
///
/// \param LookDirectionX[in] X component of the source direction vector
/// \param LookDirectionY[in] Y component of the source direction vector
/// \param LookDirectionZ[in] Z component of the source direction vector
/// \param UpDirectionX[in] X component of the source up vector
/// \param UpDirectionY[in] Y component of the source up vector
/// \param UpDirectionZ[in] Z component of the source up vector
///
    pub fn ovrAudio_SetAmbisonicOrientation(AmbisonicStream:
                                                ovrAudioAmbisonicStream,
                                            LookDirectionX: f32,
                                            LookDirectionY: f32,
                                            LookDirectionZ: f32,
                                            UpDirectionX: f32,
                                            UpDirectionY: f32,
                                            UpDirectionZ: f32) -> ovrResult;
}
extern "C" {
    /// Get orientation for ambisonic stream
///
/// \param pLookDirectionX[in] address of the X component of the source direction vector
/// \param pLookDirectionY[in] address of the Y component of the source direction vector
/// \param pLookDirectionZ[in] address of the Z component of the source direction vector
/// \param pUpDirectionX[in] address of the X component of the source up vector
/// \param pUpDirectionY[in] address of the Y component of the source up vector
/// \param pUpDirectionZ[in] address of the Z component of the source up vector
///
    pub fn ovrAudio_GetAmbisonicOrientation(AmbisonicStream:
                                                ovrAudioAmbisonicStream,
                                            pLookDirectionX: *mut f32,
                                            pLookDirectionY: *mut f32,
                                            pLookDirectionZ: *mut f32,
                                            pUpDirectionX: *mut f32,
                                            pUpDirectionY: *mut f32,
                                            pUpDirectionZ: *mut f32)
     -> ovrResult;
}
extern "C" {
    pub fn ovrAudio_SetProfilerEnabled(Context: ovrAudioContext,
                                       Enabled: ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    pub fn ovrAudio_SetProfilerPort(arg1: ovrAudioContext,
                                    Port: ::std::os::raw::c_int) -> ovrResult;
}
extern "C" {
    pub fn ovrAudio_CreateSpectrumAnalyzer(ChannelCount:
                                               ::std::os::raw::c_int,
                                           WindowLength:
                                               ::std::os::raw::c_int,
                                           Overlap: ::std::os::raw::c_int,
                                           pSpectrumAnalyzer:
                                               *mut ovrAudioSpectrumAnalyzer)
     -> ovrResult;
}
extern "C" {
    pub fn ovrAudio_DestroySpectrumAnalyzer(SpectrumAnalyzer:
                                                ovrAudioSpectrumAnalyzer)
     -> ovrResult;
}
extern "C" {
    pub fn ovrAudio_ResetSpectrumAnalyzer(SpectrumAnalyzer:
                                              ovrAudioSpectrumAnalyzer)
     -> ovrResult;
}
extern "C" {
    pub fn ovrAudio_SpectrumAnalyzerProcessBufferInterleaved(SpectrumAnalyzer:
                                                                 ovrAudioSpectrumAnalyzer,
                                                             Buffer:
                                                                 *const f32,
                                                             LengthFrames:
                                                                 ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    pub fn ovrAudio_SpectrumAnalyzerGetSpectrumInterleaved(SpectrumAnalyzer:
                                                               ovrAudioSpectrumAnalyzer,
                                                           Spectrum: *mut f32)
     -> ovrResult;
}
extern "C" {
    pub fn ovrAudio_SpectrumAnalyzerCalculateAmbisonicCoefficients(SpectrumAnalyzer:
                                                                       ovrAudioSpectrumAnalyzer,
                                                                   DirectionX:
                                                                       f32,
                                                                   DirectionY:
                                                                       f32,
                                                                   DirectionZ:
                                                                       f32,
                                                                   Coefs:
                                                                       *mut f32)
     -> ovrResult;
}
extern "C" {
    pub fn ovrAudio_SpectrumAnalyzerGetSpectrumAmbisonic(SpectrumAnalyzer:
                                                             ovrAudioSpectrumAnalyzer,
                                                         Coefs: *const f32,
                                                         Spectrum: *mut f32)
     -> ovrResult;
}
extern "C" {
    /// Set the number of ray casts per second are used for dynamic modeling, more rays mean more accurate and responsive modelling but will reduce performance
///
/// \param Context[in] context to use
/// \param RaysPerSecond[in] number of ray casts per second, default = 256
///
    pub fn ovrAudio_SetDynamicRoomRaysPerSecond(Context: ovrAudioContext,
                                                RaysPerSecond:
                                                    ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    /// Set the speed which the dynamic room interpolates, higher values will update more quickly but less smooth
///
/// \param Context[in] context to use
/// \param InterpSpeed[in] speed which it interpolates (0.0 - 1.0) default = 0.9
///
    pub fn ovrAudio_SetDynamicRoomInterpSpeed(Context: ovrAudioContext,
                                              InterpSpeed: f32) -> ovrResult;
}
extern "C" {
    /// Set the maximum distance to the wall for dynamic room modeling to constrain the size
///
/// \param Context[in] context to use
/// \param MaxWallDistance[in] distance to wall in meters, default = 50
///
    pub fn ovrAudio_SetDynamicRoomMaxWallDistance(Context: ovrAudioContext,
                                                  MaxWallDistance: f32)
     -> ovrResult;
}
extern "C" {
    /// Set the size of the cache which holds a history of the rays cast, a larger value will have more points making it more stable but less responsive
///
/// \param Context[in] context to use
/// \param RayCacheSize[in] number of rays to cache, default = 512
///
    pub fn ovrAudio_SetDynamicRoomRaysRayCacheSize(Context: ovrAudioContext,
                                                   RayCacheSize:
                                                       ::std::os::raw::c_int)
     -> ovrResult;
}
extern "C" {
    /// Update the dynamic room modeling, this will fire the ray cast calback and update the size of the room
///
/// \param Context[in] context to use
///
    pub fn ovrAudio_UpdateRoomModel(Context: ovrAudioContext, WetLevel: f32)
     -> ovrResult;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
